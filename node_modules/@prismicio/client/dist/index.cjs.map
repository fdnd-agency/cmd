{"version":3,"file":"index.cjs","sources":["../src/isRepositoryName.ts","../src/PrismicError.ts","../src/getRepositoryEndpoint.ts","../src/getRepositoryName.ts","../src/getGraphQLEndpoint.ts","../src/isRepositoryEndpoint.ts","../src/lib/castArray.ts","../src/buildQueryURL.ts","../src/lib/appendPredicates.ts","../src/lib/castThunk.ts","../src/lib/findRef.ts","../src/lib/findMasterRef.ts","../src/lib/findRefByID.ts","../src/lib/findRefByLabel.ts","../src/lib/getCookie.ts","../src/lib/minifyGraphQLQuery.ts","../src/cookie.ts","../src/ForbiddenError.ts","../src/NotFoundError.ts","../src/ParsingError.ts","../src/predicate.ts","../src/client.ts","../src/index.ts"],"sourcesContent":["/**\n * Determines if an input is a valid Prismic repository name.\n *\n * @param input - Input to test.\n *\n * @returns `true` if `input` is a valid Prismic repository name, `false` otherwise.\n */\nexport const isRepositoryName = (input: string): boolean => {\n\treturn /^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(input);\n};\n","export class PrismicError<Response> extends Error {\n\turl?: string;\n\tresponse: Response;\n\n\tconstructor(\n\t\tmessage = \"An invalid API response was returned\",\n\t\turl: string | undefined,\n\t\tresponse: Response,\n\t) {\n\t\tsuper(message);\n\n\t\tthis.url = url;\n\t\tthis.response = response;\n\t}\n}\n","import { isRepositoryName } from \"./isRepositoryName\";\nimport { PrismicError } from \"./PrismicError\";\n\n/**\n * Get a repository's Prismic Rest API V2 endpoint.\n *\n * @typeParam RepositoryName - Name of the Prismic repository.\n * @param repositoryName - Name of the repository.\n *\n * @returns The repository's Prismic Rest API V2 endpoint\n * @throws {@link Error} Thrown if an invalid repository name is provided.\n */\nexport const getRepositoryEndpoint = <RepositoryName extends string>(\n\trepositoryName: RepositoryName,\n): `https://${RepositoryName}.cdn.prismic.io/api/v2` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://${repositoryName}.cdn.prismic.io/api/v2` as const;\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t);\n\t}\n};\n","import { PrismicError } from \"./PrismicError\";\n\n/**\n * Get a Prismic repository's name from its standard Prismic Rest API V2 or\n * GraphQL endpoint.\n *\n * @typeParam RepositoryEndpoint - Prismic Rest API V2 endpoint for the repository.\n * @param repositoryEndpoint - Prismic Rest API V2 endpoint for the repository.\n *\n * @returns The Prismic repository's name.\n * @throws {@link Error} Thrown if an invalid Prismic Rest API V2 endpoint is provided.\n */\nexport const getRepositoryName = (repositoryEndpoint: string): string => {\n\ttry {\n\t\treturn new URL(repositoryEndpoint).hostname.split(\".\")[0];\n\t} catch {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic Rest API V2 endpoint was provided: ${repositoryEndpoint}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t);\n\t}\n};\n","import { isRepositoryName } from \"./isRepositoryName\";\nimport { PrismicError } from \"./PrismicError\";\n\n/**\n * Get a repository's Prismic GraphQL endpoint.\n *\n * @typeParam RepositoryName - Name of the Prismic repository.\n * @param repositoryName - Name of the repository.\n *\n * @returns The repository's Prismic REST API V2 endpoint\n */\nexport const getGraphQLEndpoint = <RepositoryName extends string>(\n\trepositoryName: RepositoryName,\n): `https://${RepositoryName}.cdn.prismic.io/graphql` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://${repositoryName}.cdn.prismic.io/graphql` as const;\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t);\n\t}\n};\n","/**\n * Determines if a string if a Prismic Rest API V2 endpoint. Note that any valid\n * URL is a valid endpoint to support network proxies.\n *\n * @param input - Input to test.\n *\n * @returns `true` if `input` is a valid Prismic Rest API V2 endpoint, `false` otherwise.\n */\nexport const isRepositoryEndpoint = (input: string): boolean => {\n\ttry {\n\t\tnew URL(input);\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n};\n","/**\n * Ensures that a value is an array. If it is already an array, it is returned\n * as is. If it is not an array, it is converted to an array with itself as its\n * only element.\n *\n * @typeParam A - Element of the array.\n * @param a - Value to ensure is an array.\n *\n * @returns `a` as an array.\n */\nexport const castArray = <A>(a: A | A[]): A[] => (Array.isArray(a) ? a : [a]);\n","import { castArray } from \"./lib/castArray\";\n\nimport { ValueOf, Ordering, Route } from \"./types\";\n\n/**\n * Parameters for the Prismic REST API V2.\n *\n * {@link https://prismic.io/docs/technologies/introduction-to-the-content-query-api}\n */\nexport interface QueryParams {\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * The `pageSize` parameter defines the maximum number of documents that the\n\t * API will return for your query.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#pagesize}\n\t */\n\tpageSize?: number;\n\n\t/**\n\t * The `page` parameter defines the pagination for the result of your query.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#page}\n\t */\n\tpage?: number;\n\n\t/**\n\t * The `after` parameter can be used along with the orderings option. It will\n\t * remove all the documents except for those after the specified document in the list.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#after}\n\t */\n\tafter?: string;\n\n\t/**\n\t * The `fetch` parameter is used to make queries faster by only retrieving the\n\t * specified field(s).\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#fetch}\n\t */\n\tfetch?: string | string[];\n\n\t/**\n\t * The `fetchLinks` parameter allows you to retrieve a specific content field\n\t * from a linked document and add it to the document response object.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#fetchlinks}\n\t */\n\tfetchLinks?: string | string[];\n\n\t/**\n\t * The `graphQuery` parameter allows you to specify which fields to retrieve\n\t * and what content to retrieve from Linked Documents / Content Relationships.\n\t *\n\t * {@link https://prismic.io/docs/technologies/graphquery-rest-api}\n\t */\n\tgraphQuery?: string;\n\n\t/**\n\t * The `lang` option defines the language code for the results of your query.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#lang}\n\t */\n\tlang?: string;\n\n\t/**\n\t * The `orderings` parameter orders the results by the specified field(s). You\n\t * can specify as many fields as you want.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#orderings}\n\t */\n\torderings?: Ordering | string | (Ordering | string)[];\n\n\t/**\n\t * The `routes` option allows you to define how a document's `url` field is resolved.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#route-resolver}\n\t */\n\troutes?: Route | string | (Route | string)[];\n}\n\n/**\n * Arguments for `buildQueryURL` to construct a Query URL.\n */\ntype BuildQueryURLParams = {\n\t/**\n\t * Ref used to query documents.\n\t *\n\t * {@link https://prismic.io/docs/technologies/introduction-to-the-content-query-api#prismic-api-ref}\n\t */\n\tref: string;\n\n\t/**\n\t * Ref used to populate Integration Fields with the latest content.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/integration-fields}\n\t */\n\tintegrationFieldsRef?: string;\n\n\t/**\n\t * One or more predicates to filter documents for the query.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api}\n\t */\n\tpredicates?: string | string[];\n};\n\n/**\n * Parameters in this map have been renamed from the official Prismic REST API\n * V2 specification for better developer ergonomics.\n *\n * These parameters are renamed to their mapped value.\n */\nconst RENAMED_PARAMS = {\n\taccessToken: \"access_token\",\n} as const;\n\n/**\n * A valid parameter name for the Prismic REST API V2.\n */\ntype ValidParamName =\n\t| Exclude<\n\t\t\tkeyof QueryParams,\n\t\t\tkeyof typeof RENAMED_PARAMS | keyof BuildQueryURLParams\n\t  >\n\t| ValueOf<typeof RENAMED_PARAMS>;\n\n/**\n * Converts an Ordering to a string that is compatible with Prismic's REST API.\n * If the value provided is already a string, no conversion is performed.\n *\n * @param ordering - Ordering to convert.\n *\n * @returns String representation of the Ordering.\n */\nconst castOrderingToString = (ordering: Ordering | string): string =>\n\ttypeof ordering === \"string\"\n\t\t? ordering\n\t\t: [\n\t\t\t\tordering.field,\n\t\t\t\tordering.direction === \"desc\" ? ordering.direction : undefined,\n\t\t  ]\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.join(\" \");\n\nexport type BuildQueryURLArgs = QueryParams & BuildQueryURLParams;\n\n/**\n * Build a Prismic REST API V2 URL to request documents from a repository. The\n * paginated response for this URL includes documents matching the parameters.\n *\n * A ref is required to make a request. Request the `endpoint` URL to retrieve a\n * list of available refs.\n *\n * Type the JSON response with `Query`.\n *\n * {@link https://prismic.io/docs/technologies/introduction-to-the-content-query-api#prismic-api-ref}\n * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api}\n *\n * @param endpoint - URL to the repository's REST API V2.\n * @param args - Arguments to filter and scope the query.\n *\n * @returns URL that can be used to request documents from the repository.\n */\nexport const buildQueryURL = (\n\tendpoint: string,\n\targs: BuildQueryURLArgs,\n): string => {\n\tconst { predicates, ...params } = args;\n\n\tconst url = new URL(`documents/search`, `${endpoint}/`);\n\n\tif (predicates) {\n\t\tfor (const predicate of castArray(predicates)) {\n\t\t\turl.searchParams.append(\"q\", `[${predicate}]`);\n\t\t}\n\t}\n\n\t// Iterate over each parameter and add it to the URL. In some cases, the\n\t// parameter value needs to be transformed to fit the REST API.\n\tfor (const k in params) {\n\t\tconst name = (RENAMED_PARAMS[k as keyof typeof RENAMED_PARAMS] ??\n\t\t\tk) as ValidParamName;\n\n\t\tlet value = params[k as keyof typeof params];\n\n\t\tif (name === \"orderings\") {\n\t\t\tconst scopedValue = params[name];\n\n\t\t\tif (scopedValue != null) {\n\t\t\t\tconst v = castArray(scopedValue)\n\t\t\t\t\t.map((ordering) => castOrderingToString(ordering))\n\t\t\t\t\t.join(\",\");\n\n\t\t\t\tvalue = `[${v}]`;\n\t\t\t}\n\t\t} else if (name === \"routes\") {\n\t\t\tif (typeof params[name] === \"object\") {\n\t\t\t\tvalue = JSON.stringify(castArray(params[name]));\n\t\t\t}\n\t\t}\n\n\t\tif (value != null) {\n\t\t\turl.searchParams.set(name, castArray(value).join(\",\"));\n\t\t}\n\t}\n\n\treturn url.toString();\n};\n","import { castArray } from \"./castArray\";\n\ninterface WithPredicates {\n\tpredicates?: string | string[];\n}\n\n/**\n * Adds one or more predicates to an object with a `predicates` property.\n * Appended predicates are added to the end of the existing list.\n *\n * @typeParam T - Object to which predicates will be append.\n * @param objWithPredicates - Object to append predicates on the `predicates` property.\n * @param predicates - One or more predicates to append.\n *\n * @returns The object with the appended predicates.\n */\nexport const appendPredicates = <T extends WithPredicates>(\n\tobjWithPredicates: T = {} as T,\n\tpredicates: string | string[],\n) => {\n\treturn {\n\t\t...objWithPredicates,\n\t\tpredicates: [\n\t\t\t...(objWithPredicates.predicates || []),\n\t\t\t...castArray(predicates),\n\t\t],\n\t};\n};\n","/**\n * Ensures that a value is a thunk. If it is already a thunk, it is returned as\n * is. If it is not a thunk, it is converted to a thunk.\n *\n * @typeParam A - Value returned by the thunk.\n * @param a - Value to ensure is a thunk.\n *\n * @returns `a` as a a thunk.\n */\nexport const castThunk = <A>(a: A | (() => A)): (() => A) =>\n\ttypeof a === \"function\" ? (a as () => A) : () => a;\n","import * as prismicT from \"@prismicio/types\";\n\nimport { PrismicError } from \"../PrismicError\";\n\n/**\n * Returns the first ref from a list that passes a predicate (a function that\n * returns true).\n *\n * @param refs - A list of refs to search.\n * @param predicate - A function that determines if a ref from the list matches\n *   the criteria.\n *\n * @returns The first matching ref.\n * @throws If a matching ref cannot be found.\n */\nexport const findRef = (\n\trefs: prismicT.Ref[],\n\tpredicate: (ref: prismicT.Ref) => boolean,\n): prismicT.Ref => {\n\tconst ref = refs.find((ref) => predicate(ref));\n\n\tif (!ref) {\n\t\tthrow new PrismicError(\"Ref could not be found.\", undefined, undefined);\n\t}\n\n\treturn ref;\n};\n","import * as prismicT from \"@prismicio/types\";\n\nimport { findRef } from \"./findRef\";\n\n/**\n * Returns the master ref from a list of given refs.\n *\n * @param refs - A list of refs to search.\n *\n * @returns The master ref from the list.\n * @throws If a matching ref cannot be found.\n */\nexport const findMasterRef = (refs: prismicT.Ref[]): prismicT.Ref => {\n\treturn findRef(refs, (ref) => ref.isMasterRef);\n};\n","import * as prismicT from \"@prismicio/types\";\n\nimport { findRef } from \"./findRef\";\n\n/**\n * Returns the ref from a list of given refs with a matching ID.\n *\n * @param refs - A list of refs to search.\n * @param id - The ID of the ref to find.\n *\n * @returns The ref with a matching ID from the list.\n * @throws If a matching ref cannot be found.\n */\nexport const findRefByID = (refs: prismicT.Ref[], id: string): prismicT.Ref => {\n\treturn findRef(refs, (ref) => ref.id === id);\n};\n","import * as prismicT from \"@prismicio/types\";\n\nimport { findRef } from \"./findRef\";\n\n/**\n * Returns the ref from a list of given refs with a matching label.\n *\n * @param refs - A list of refs to search.\n * @param id - The label of the ref to find.\n *\n * @returns The ref with a matching label from the list.\n * @throws If a matching ref cannot be found.\n */\nexport const findRefByLabel = (\n\trefs: prismicT.Ref[],\n\tlabel: string,\n): prismicT.Ref => {\n\treturn findRef(refs, (ref) => ref.label === label);\n};\n","/**\n * The following code is a modifed version of `es-cookie` taken from\n * https://github.com/theodorejb/es-cookie\n *\n * Copyright 2017 Theodore Brown\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.*\n */\n\nconst readValue = (value: string): string => {\n\treturn value.replace(/%3B/g, \";\");\n};\n\nexport const parse = (cookieString: string): { [name: string]: string } => {\n\tconst result: { [name: string]: string } = {};\n\tconst cookies = cookieString.split(\"; \");\n\n\tfor (const cookie of cookies) {\n\t\tconst parts = cookie.split(\"=\");\n\t\tconst value = parts.slice(1).join(\"=\");\n\t\tconst name = readValue(parts[0]).replace(/%3D/g, \"=\");\n\t\tresult[name] = readValue(value);\n\t}\n\n\treturn result;\n};\n\nconst getAll = (cookieStore: string): { [name: string]: string } =>\n\tparse(cookieStore);\n\n/**\n * Returns the value of a cookie from a given cookie store.\n *\n * @param name - Of the cookie.\n * @param cookieJar - The stringified cookie store from which to read the cookie.\n *\n * @returns The value of the cookie, if it exists.\n */\nexport const getCookie = (\n\tname: string,\n\tcookieJar: string,\n): string | undefined => getAll(cookieJar)[name];\n","/**\n * Minifies a GraphQL query by removing whitespace where possible.\n *\n * @param query - GraphQL query to minify.\n *\n * @returns A minified version of `query`.\n */\nexport const minifyGraphQLQuery = (query: string): string => {\n\treturn query.replace(\n\t\t/(\\n| )*( |{|})(\\n| )*/gm,\n\t\t(_chars, _spaces, brackets) => brackets,\n\t);\n};\n","/**\n * The well-known name of the cookie used to store a Prismic preview session's ref.\n */\nexport const preview = \"io.prismic.preview\";\n","import { PrismicError } from \"./PrismicError\";\n\ntype ForbiddenErrorRepositoryAPIResponse = {\n\ttype: string;\n\tmessage: string;\n};\n\ntype ForbiddenErrorQueryAPIResponse = {\n\terror: string;\n};\n\nexport class ForbiddenError extends PrismicError<\n\tForbiddenErrorRepositoryAPIResponse | ForbiddenErrorQueryAPIResponse\n> {}\n","import { PrismicError } from \"./PrismicError\";\n\nexport class NotFoundError extends PrismicError<undefined> {}\n","import { PrismicError } from \"./PrismicError\";\n\ntype ParsingErrorAPIResponse = {\n\ttype: \"parsing-error\";\n\tmessage: string;\n\tline: number;\n\tcolumn: number;\n\tid: number;\n\tlocation: string;\n};\n\nexport class ParsingError extends PrismicError<ParsingErrorAPIResponse> {}\n","/**\n * Formats the value of a predicate element to a stringified version accepted by\n * the Prismic REST API.\n *\n * @param value - Value to format.\n *\n * @returns `value` formatted for the Prismic REST API.\n */\nconst formatValue = (\n\tvalue:\n\t\t| string\n\t\t| number\n\t\t| Date\n\t\t| unknown\n\t\t| (string | number | Date | unknown)[],\n): string => {\n\tif (Array.isArray(value)) {\n\t\treturn `[${value.map(formatValue).join(\", \")}]`;\n\t}\n\n\tif (typeof value === \"string\") {\n\t\treturn `\"${value}\"`;\n\t}\n\n\tif (value instanceof Date) {\n\t\treturn `${value.getTime()}`;\n\t}\n\n\treturn `${value}`;\n};\n\n/**\n * Creates a predicate builder function for predicates with a path and arguments.\n *\n * @typeParam Args - Arguments for the predicate.\n * @param name - Name of the predicate used in the resulting string.\n *\n * @returns Predicate builder function for the given name.\n */\nconst pathWithArgsPredicate = <Args extends unknown[]>(name: string) => {\n\t/**\n\t * @param path - Path to the value to be compared.\n\t */\n\tconst fn = (path: string, ...args: Args): string => {\n\t\tconst formattedArgs = args.map(formatValue).join(\", \");\n\t\tconst joiner = path && args.length ? \", \" : \"\";\n\n\t\treturn `[${name}(${path}${joiner}${formattedArgs})]`;\n\t};\n\n\treturn fn;\n};\n\n/**\n * Creates a predicate builder function for predicates with only a path.\n *\n * @param name - Name of the predicate used in the resulting string.\n *\n * @returns Predicate builder function for the given name.\n */\nconst pathPredicate = (name: string) => {\n\tconst predicateFn = pathWithArgsPredicate(name);\n\n\t/**\n\t * @param path - Path for the predicate.\n\t */\n\tconst fn = (path: string): string => {\n\t\treturn predicateFn(path);\n\t};\n\n\treturn fn;\n};\n\n/**\n * Creates a predicate builder function for predicates with only arguments and no path.\n *\n * @param name - Name of the predicate used in the resulting string.\n *\n * @returns Predicate builder function for the given name.\n */\nconst argsPredicate = <Args extends unknown[]>(name: string) => {\n\tconst predicateFn = pathWithArgsPredicate<Args>(name);\n\n\t/**\n\t * @param args - Arguments for the predicate.\n\t */\n\tconst fn = (...args: Args): string => {\n\t\treturn predicateFn(\"\", ...args);\n\t};\n\n\treturn fn;\n};\n\nexport const predicate = {\n\t/**\n\t * The `at` predicate checks that the path matches the described value\n\t * exactly. It takes a single value for a field or an array (only for tags).\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#at}\n\t */\n\tat: pathWithArgsPredicate<\n\t\t[value: string | number | boolean | Date | string[]]\n\t>(\"at\"),\n\n\t/**\n\t * The `not` predicate checks that the path doesn't match the provided value\n\t * exactly. It takes a single value for a field or an array (only for tags).\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#not}\n\t */\n\tnot: pathWithArgsPredicate<\n\t\t[value: string | number | boolean | Date | string[]]\n\t>(\"not\"),\n\n\t/**\n\t * The `any` predicate takes an array of values. It works exactly the same way\n\t * as the `at` operator, but checks whether the fragment matches any of the\n\t * values in the array.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#any}\n\t */\n\tany: pathWithArgsPredicate<[values: (string | number | boolean | Date)[]]>(\n\t\t\"any\",\n\t),\n\n\t/**\n\t * The `in` predicate is used specifically to retrieve an array of documents\n\t * by their IDs or UIDs. This predicate is much more efficient at this than\n\t * the any predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#in}\n\t */\n\tin: pathWithArgsPredicate<[values: string[]]>(\"in\"),\n\n\t/**\n\t * The `fulltext` predicate provides two capabilities:\n\t *\n\t * 1. Checking if a certain string is anywhere inside a document (this is what\n\t *    you should use to make your project's search engine feature)\n\t * 2. Checking if the string is contained inside a specific custom typeâ€™s Rich\n\t *    Text or Key Text fragment.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#fulltext}\n\t */\n\tfulltext: pathWithArgsPredicate<[searchTerms: string]>(\"fulltext\"),\n\n\t/**\n\t * The `has` predicate checks whether a fragment has a value. It will return\n\t * all the documents of the specified type that contain a value for the\n\t * specified field.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#has}\n\t */\n\thas: pathPredicate(\"has\"),\n\n\t/**\n\t * The `missing` predicate checks if a fragment doesn't have a value. It will\n\t * return all the documents of the specified type that do not contain a value\n\t * for the specified field.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#missing}\n\t */\n\tmissing: pathPredicate(\"missing\"),\n\n\t/**\n\t * The `similar` predicate takes the ID of a document, and returns a list of\n\t * documents with similar content. This allows you to build an automated\n\t * content discovery feature (for example, a \"Related posts\" section).\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#similar}\n\t */\n\tsimilar: argsPredicate<[id: string, value: number]>(\"similar\"),\n\n\t/**\n\t * The `geopoint.near` predicate checks that the value in the path is within\n\t * the radius of the given coordinates.\n\t *\n\t * This predicate will only work for a GeoPoint field.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#near}\n\t */\n\tgeopointNear:\n\t\tpathWithArgsPredicate<\n\t\t\t[latitude: number, longitude: number, radius: number]\n\t\t>(\"geopoint.near\"),\n\n\t/**\n\t * The `number.lt` predicate checks that the value in the number field is less\n\t * than the value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#lt-less-than}\n\t */\n\tnumberLessThan: pathWithArgsPredicate<[value: number]>(\"number.lt\"),\n\n\t/**\n\t * The `number.gt` predicate checks that the value in the number field is\n\t * greater than the value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#gt-greater-than}\n\t */\n\tnumberGreaterThan: pathWithArgsPredicate<[value: number]>(\"number.gt\"),\n\n\t/**\n\t * The `number.inRange` predicate checks that the value in the path is within\n\t * the two values passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#inrange}\n\t */\n\tnumberInRange:\n\t\tpathWithArgsPredicate<[lowerLimit: number, upperLimit: number]>(\n\t\t\t\"number.inRange\",\n\t\t),\n\n\t/**\n\t * The `date.after` predicate checks that the value in the path is after the\n\t * date value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#after}\n\t */\n\tdateAfter:\n\t\tpathWithArgsPredicate<[date: string | number | Date]>(\"date.after\"),\n\n\t/**\n\t * The `date.before` predicate checks that the value in the path is before the\n\t * date value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#before}\n\t */\n\tdateBefore:\n\t\tpathWithArgsPredicate<[date: string | number | Date]>(\"date.before\"),\n\n\t/**\n\t * The `date.between` predicate checks that the value in the path is within\n\t * the date values passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#between}\n\t */\n\tdateBetween:\n\t\tpathWithArgsPredicate<\n\t\t\t[startDate: string | number | Date, endDate: string | number | Date]\n\t\t>(\"date.between\"),\n\n\t/**\n\t * The `date.day-of-month` predicate checks that the value in the path is\n\t * equal to the day of the month passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofmonth}\n\t */\n\tdateDayOfMonth: pathWithArgsPredicate<[day: number]>(\"date.day-of-month\"),\n\n\t/**\n\t * The `date.day-of-month-after` predicate checks that the value in the path\n\t * is after the day of the month passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofmonthafter}\n\t */\n\tdateDayOfMonthAfter: pathWithArgsPredicate<[day: number]>(\n\t\t\"date.day-of-month-after\",\n\t),\n\n\t/**\n\t * The `date.day-of-month-before` predicate checks that the value in the path\n\t * is before the day of the month passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofmonthbefore}\n\t */\n\tdateDayOfMonthBefore: pathWithArgsPredicate<[day: number]>(\n\t\t\"date.day-of-month-before\",\n\t),\n\n\t/**\n\t * The `date.day-of-week` predicate checks that the value in the path is equal\n\t * to the day of the week passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofweek}\n\t */\n\tdateDayOfWeek:\n\t\tpathWithArgsPredicate<[day: string | number]>(\"date.day-of-week\"),\n\n\t/**\n\t * The `date.day-of-week-after` predicate checks that the value in the path is\n\t * after the day of the week passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofweekafter}\n\t */\n\tdateDayOfWeekAfter: pathWithArgsPredicate<[day: string | number]>(\n\t\t\"date.day-of-week-after\",\n\t),\n\n\t/**\n\t * The date.day-of-week-before predicate checks that the value in the path is\n\t * before the day of the week passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofweekbefore}\n\t */\n\tdateDayOfWeekBefore: pathWithArgsPredicate<[day: string | number]>(\n\t\t\"date.day-of-week-before\",\n\t),\n\n\t/**\n\t * The `date.month` predicate checks that the value in the path occurs in the\n\t * month value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#month}\n\t */\n\tdateMonth: pathWithArgsPredicate<[month: string | number]>(\"date.month\"),\n\n\t/**\n\t * The `date.month-after` predicate checks that the value in the path occurs\n\t * in any month after the value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#monthafter}\n\t */\n\tdateMonthAfter:\n\t\tpathWithArgsPredicate<[month: string | number]>(\"date.month-after\"),\n\n\t/**\n\t * The `date.month-before` predicate checks that the value in the path occurs\n\t * in any month before the value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#monthbefore}\n\t */\n\tdateMonthBefore:\n\t\tpathWithArgsPredicate<[month: string | number]>(\"date.month-before\"),\n\n\t/**\n\t * The `date.year` predicate checks that the value in the path occurs in the\n\t * year value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#year}\n\t */\n\tdateYear: pathWithArgsPredicate<[year: number]>(\"date.year\"),\n\n\t/**\n\t * The `date.hour` predicate checks that the value in the path occurs within\n\t * the hour value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#hour}\n\t */\n\tdateHour: pathWithArgsPredicate<[hour: number]>(\"date.hour\"),\n\n\t/**\n\t * The `date.hour-after` predicate checks that the value in the path occurs\n\t * after the hour value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#hourafter}\n\t */\n\tdateHourAfter: pathWithArgsPredicate<[hour: number]>(\"date.hour-after\"),\n\n\t/**\n\t * The `date.hour-before` predicate checks that the value in the path occurs\n\t * before the hour value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#hourbefore}\n\t */\n\tdateHourBefore: pathWithArgsPredicate<[hour: number]>(\"date.hour-before\"),\n};\n","import * as prismicT from \"@prismicio/types\";\nimport * as prismicH from \"@prismicio/helpers\";\n\nimport { appendPredicates } from \"./lib/appendPredicates\";\nimport { castArray } from \"./lib/castArray\";\nimport { castThunk } from \"./lib/castThunk\";\nimport { findMasterRef } from \"./lib/findMasterRef\";\nimport { findRefByID } from \"./lib/findRefByID\";\nimport { findRefByLabel } from \"./lib/findRefByLabel\";\nimport { getCookie } from \"./lib/getCookie\";\nimport { minifyGraphQLQuery } from \"./lib/minifyGraphQLQuery\";\n\nimport * as cookie from \"./cookie\";\nimport {\n\tAbortSignalLike,\n\tFetchLike,\n\tHttpRequestLike,\n\tExtractDocumentType,\n} from \"./types\";\nimport { ForbiddenError } from \"./ForbiddenError\";\nimport { NotFoundError } from \"./NotFoundError\";\nimport { ParsingError } from \"./ParsingError\";\nimport { PrismicError } from \"./PrismicError\";\nimport { buildQueryURL, BuildQueryURLArgs } from \"./buildQueryURL\";\nimport { getRepositoryEndpoint } from \"./getRepositoryEndpoint\";\nimport { isRepositoryEndpoint } from \"./isRepositoryEndpoint\";\nimport { predicate } from \"./predicate\";\n\n/**\n * The largest page size allowed by the Prismic REST API V2. This value is used\n * to minimize the number of requests required to query content.\n */\nconst MAX_PAGE_SIZE = 100;\n\n/**\n * The number of milliseconds in which repository metadata is considered valid.\n * A ref can be invalidated quickly depending on how frequently content is\n * updated in the Prismic repository. As such, repository's metadata can only be\n * considered valid for a short amount of time.\n */\nexport const REPOSITORY_CACHE_TTL = 5000;\n\n/**\n * The number of milliseconds in which a multi-page `getAll` (e.g. `getAll`,\n * `getAllByType`, `getAllByTag`) will wait between individual page requests.\n *\n * This is done to ensure API performance is sustainable and reduces the chance\n * of a failed API request due to overloading.\n */\nexport const GET_ALL_QUERY_DELAY = 500;\n\n/**\n * Modes for client ref management.\n */\nenum RefStateMode {\n\t/**\n\t * Use the repository's master ref.\n\t */\n\tMaster = \"Master\",\n\n\t/**\n\t * Use a given Release identified by its ID.\n\t */\n\tReleaseID = \"ReleaseID\",\n\n\t/**\n\t * Use a given Release identified by its label.\n\t */\n\tReleaseLabel = \"ReleaseLabel\",\n\n\t/**\n\t * Use a given ref.\n\t */\n\tManual = \"Manual\",\n}\n\n/**\n * An object containing stateful information about a client's ref strategy.\n */\ntype RefState = {\n\t/**\n\t * Determines if automatic preview support is enabled.\n\t */\n\tautoPreviewsEnabled: boolean;\n\n\t/**\n\t * An optional HTTP server request object used during previews if automatic\n\t * previews are enabled.\n\t */\n\thttpRequest?: HttpRequestLike;\n} & (\n\t| {\n\t\t\tmode: RefStateMode.Master;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseID;\n\t\t\treleaseID: string;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseLabel;\n\t\t\treleaseLabel: string;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.Manual;\n\t\t\tref: RefStringOrThunk;\n\t  }\n);\n\n/**\n * A ref or a function that returns a ref. If a static ref is known, one can be\n * given. If the ref must be fetched on-demand, a function can be provided. This\n * function can optionally be asynchronous.\n */\ntype RefStringOrThunk =\n\t| string\n\t| (() => string | undefined | Promise<string | undefined>);\n\n/**\n * Configuration for clients that determine how content is queried.\n */\nexport type ClientConfig = {\n\t/**\n\t * The secure token for accessing the Prismic repository. This is only\n\t * required if the repository is set to private.\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * A string representing a version of the Prismic repository's content. This\n\t * may point to the latest version (called the \"master ref\"), or a preview\n\t * with draft content.\n\t */\n\tref?: RefStringOrThunk;\n\n\t/**\n\t * A list of Route Resolver objects that define how a document's `url` field\n\t * is resolved.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>;\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\"\n\t>;\n\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetch?: FetchLike;\n};\n\n/**\n * Parameters for any client method that use `fetch()`. Only a subset of\n * `fetch()` parameters are exposed.\n */\ntype FetchParams = {\n\t/**\n\t * An `AbortSignal` provided by an `AbortController`. This allows the network\n\t * request to be cancelled if necessary.\n\t *\n\t * {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal}\n\t */\n\tsignal?: AbortSignalLike;\n};\n\n/**\n * Parameters specific to client methods that fetch all documents. These methods\n * start with `getAll` (for example, `getAllByType`).\n */\ntype GetAllParams = {\n\t/**\n\t * Limit the number of documents queried. If a number is not provided, there\n\t * will be no limit and all matching documents will be returned.\n\t */\n\tlimit?: number;\n};\n\n/**\n * Arguments to determine how the URL for a preview session is resolved.\n */\ntype ResolvePreviewArgs<LinkResolverReturnType> = {\n\t/**\n\t * A function that maps a Prismic document to a URL within your app.\n\t */\n\tlinkResolver?: prismicH.LinkResolverFunction<LinkResolverReturnType>;\n\n\t/**\n\t * A fallback URL if the Link Resolver does not return a value.\n\t */\n\tdefaultURL: string;\n\n\t/**\n\t * The preview token (also known as a ref) that will be used to query preview\n\t * content from the Prismic repository.\n\t */\n\tpreviewToken?: string;\n\n\t/**\n\t * The previewed document that will be used to determine the destination URL.\n\t */\n\tdocumentID?: string;\n};\n\n/**\n * Creates a predicate to filter content by document type.\n *\n * @param documentType - The document type to filter queried content.\n *\n * @returns A predicate that can be used in a Prismic REST API V2 request.\n */\nconst typePredicate = (documentType: string): string =>\n\tpredicate.at(\"document.type\", documentType);\n\n/**\n * Creates a predicate to filter content by document tags. All tags are required\n * on the document.\n *\n * @param tags - Document tags to filter queried content.\n *\n * @returns A predicate that can be used in a Prismic REST API V2 request.\n */\nconst everyTagPredicate = (tags: string | string[]): string =>\n\tpredicate.at(\"document.tags\", castArray(tags));\n\n/**\n * Creates a predicate to filter content by document tags. At least one matching\n * tag is required on the document.\n *\n * @param tags - Document tags to filter queried content.\n *\n * @returns A predicate that can be used in a Prismic REST API V2 request.\n */\nconst someTagsPredicate = (tags: string | string[]): string =>\n\tpredicate.any(\"document.tags\", castArray(tags));\n\n/**\n * Type definitions for the `createClient()` function. May be augmented by\n * third-party libraries.\n */\nexport interface CreateClient {\n\t<TDocuments extends prismicT.PrismicDocument>(\n\t\t...args: ConstructorParameters<typeof Client>\n\t): Client<TDocuments>;\n}\n\n/**\n * Creates a Prismic client that can be used to query a repository.\n *\n * @example\n *\n * ```ts\n * // With a repository name.\n * createClient(\"qwerty\");\n *\n * // Or with a full Prismic Rest API V2 endpoint.\n * createClient(\"https://qwerty.cdn.prismic.io/api/v2\");\n * ```\n *\n * @typeParam TDocuments - A map of Prismic document type IDs mapped to their\n *   TypeScript type.\n * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n *   API V2 endpoint for the repository.\n * @param options - Configuration that determines how content will be queried\n *   from the Prismic repository.\n *\n * @returns A client that can query content from the repository.\n */\nexport const createClient: CreateClient = <\n\tTDocuments extends prismicT.PrismicDocument,\n>(\n\trepositoryNameOrEndpoint: string,\n\toptions?: ClientConfig,\n) => new Client<TDocuments>(repositoryNameOrEndpoint, options);\n\n/**\n * A client that allows querying content from a Prismic repository.\n *\n * If used in an environment where a global `fetch` function is unavailable,\n * such as Node.js, the `fetch` option must be provided as part of the `options`\n * parameter.\n *\n * @typeParam TDocuments - Document types that are registered for the Prismic\n *   repository. Query methods will automatically be typed based on this type.\n */\nexport class Client<\n\tTDocuments extends prismicT.PrismicDocument = prismicT.PrismicDocument,\n> {\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getRepositoryEndpoint` for the default endpoint).\n\t */\n\tendpoint: string;\n\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * A list of Route Resolver objects that define how a document's `url` field\n\t * is resolved.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>;\n\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetchFn: FetchLike;\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\"\n\t>;\n\n\t/**\n\t * The client's ref mode state. This determines which ref is used during queries.\n\t */\n\tprivate refState: RefState = {\n\t\tmode: RefStateMode.Master,\n\t\tautoPreviewsEnabled: true,\n\t};\n\n\t/**\n\t * Cached repository value.\n\t */\n\tprivate cachedRepository: prismicT.Repository | undefined;\n\n\t/**\n\t * Timestamp at which the cached repository data is considered stale.\n\t */\n\tprivate cachedRepositoryExpiration = 0;\n\n\t/**\n\t * Creates a Prismic client that can be used to query a repository.\n\t *\n\t * If used in an environment where a global `fetch` function is unavailable,\n\t * such as Node.js, the `fetch` option must be provided as part of the\n\t * `options` parameter.\n\t *\n\t * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n\t *   API V2 endpoint for the repository.\n\t * @param options - Configuration that determines how content will be queried\n\t *   from the Prismic repository.\n\t *\n\t * @returns A client that can query content from the repository.\n\t */\n\tconstructor(repositoryNameOrEndpoint: string, options: ClientConfig = {}) {\n\t\tif (isRepositoryEndpoint(repositoryNameOrEndpoint)) {\n\t\t\tif (\n\t\t\t\tprocess.env.NODE_ENV === \"development\" &&\n\t\t\t\t/\\.prismic\\.io\\/(?!api\\/v2\\/?)/.test(repositoryNameOrEndpoint)\n\t\t\t) {\n\t\t\t\tthrow new PrismicError(\n\t\t\t\t\t\"@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.\",\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.endpoint = repositoryNameOrEndpoint;\n\t\t} else {\n\t\t\tthis.endpoint = getRepositoryEndpoint(repositoryNameOrEndpoint);\n\t\t}\n\n\t\tthis.accessToken = options.accessToken;\n\t\tthis.routes = options.routes;\n\t\tthis.defaultParams = options.defaultParams;\n\n\t\tif (options.ref) {\n\t\t\tthis.queryContentFromRef(options.ref);\n\t\t}\n\n\t\tif (typeof options.fetch === \"function\") {\n\t\t\tthis.fetchFn = options.fetch;\n\t\t} else if (typeof globalThis.fetch === \"function\") {\n\t\t\tthis.fetchFn = globalThis.fetch;\n\t\t} else {\n\t\t\tthrow new PrismicError(\n\t\t\t\t\"A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.\",\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t);\n\t\t}\n\n\t\t// If the global fetch function is used, we must bind it to the global scope.\n\t\tif (this.fetchFn === globalThis.fetch) {\n\t\t\tthis.fetchFn = this.fetchFn.bind(globalThis);\n\t\t}\n\n\t\tthis.graphQLFetch = this.graphQLFetch.bind(this);\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in browser environments. This is enabled by default in the browser.\n\t *\n\t * For server environments, use `enableAutoPreviewsFromReq`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.enableAutoPreviews();\n\t * ```\n\t *\n\t * @see enableAutoPreviewsFromReq\n\t */\n\tenableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = true;\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in server environments. This is disabled by default on the server.\n\t *\n\t * For browser environments, use `enableAutoPreviews`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // In an express app\n\t * app.get(\"/\", function (req, res) {\n\t * \tclient.enableAutoPreviewsFromReq(req);\n\t * });\n\t * ```\n\t *\n\t * @param req - An HTTP server request object containing the request's cookies.\n\t */\n\tenableAutoPreviewsFromReq<R extends HttpRequestLike>(req: R): void {\n\t\tthis.refState.httpRequest = req;\n\t\tthis.refState.autoPreviewsEnabled = true;\n\t}\n\n\t/**\n\t * Disables the client from automatically querying content from a preview\n\t * session if one is active.\n\t *\n\t * Automatic preview content querying is enabled by default unless this method\n\t * is called.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.disableAutoPreviews();\n\t * ```\n\t */\n\tdisableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = false;\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository.\n\t *\n\t * @deprecated Use `get` instead.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.query(\n\t * \tprismic.predicate.at(\"document.type\", \"page\"),\n\t * );\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A paginated response containing the result of the query.\n\t */\n\tasync query<TDocument extends TDocuments>(\n\t\tpredicates: NonNullable<BuildQueryURLArgs[\"predicates\"]>,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"predicates\">> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\tconst url = await this.buildQueryURL({ ...params, predicates });\n\n\t\treturn await this.fetch<prismicT.Query<TDocument>>(url, params);\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.get();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A paginated response containing the result of the query.\n\t */\n\tasync get<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\tconst url = await this.buildQueryURL(params);\n\n\t\treturn await this.fetch<prismicT.Query<TDocument>>(url, params);\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository and returns only the first\n\t * result, if any.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getFirst();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t * @param params - Parameters to filter, sort, and paginate results. @returns\n\t *   The first result of the query, if any.\n\t */\n\tasync getFirst<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\tconst url = await this.buildQueryURL(params);\n\t\tconst result = await this.fetch<prismicT.Query<TDocument>>(url, params);\n\n\t\tconst firstResult = result.results[0];\n\n\t\tif (firstResult) {\n\t\t\treturn firstResult;\n\t\t}\n\n\t\tthrow new PrismicError(\"No documents were returned\", url, undefined);\n\t}\n\n\t/**\n\t * **IMPORTANT**: Avoid using `dangerouslyGetAll` as it may be slower and\n\t * require more resources than other methods. Prefer using other methods that\n\t * filter by predicates such as `getAllByType`.\n\t *\n\t * Queries content from the Prismic repository and returns all matching\n\t * content. If no predicates are provided, all documents will be fetched.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.dangerouslyGetAll();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A list of documents matching the query.\n\t */\n\tasync dangerouslyGetAll<TDocument extends TDocuments>(\n\t\tparams: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams = {},\n\t): Promise<TDocument[]> {\n\t\tconst { limit = Infinity, ...actualParams } = params;\n\t\tconst resolvedParams = {\n\t\t\t...actualParams,\n\t\t\tpageSize: Math.min(\n\t\t\t\tlimit,\n\t\t\t\tactualParams.pageSize || this.defaultParams?.pageSize || MAX_PAGE_SIZE,\n\t\t\t),\n\t\t};\n\n\t\tconst documents: TDocument[] = [];\n\t\tlet latestResult: prismicT.Query<TDocument> | undefined;\n\n\t\twhile (\n\t\t\t(!latestResult || latestResult.next_page) &&\n\t\t\tdocuments.length < limit\n\t\t) {\n\t\t\tconst page = latestResult ? latestResult.page + 1 : undefined;\n\n\t\t\tlatestResult = await this.get<TDocument>({ ...resolvedParams, page });\n\t\t\tdocuments.push(...latestResult.results);\n\n\t\t\tif (latestResult.next_page) {\n\t\t\t\tawait new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY));\n\t\t\t}\n\t\t}\n\n\t\treturn documents.slice(0, limit);\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific ID.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @typeParam TDocument- Type of the Prismic document returned.\n\t * @param id - ID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with an ID matching the `id` parameter, if a matching\n\t *   document exists.\n\t */\n\tasync getByID<TDocument extends TDocuments>(\n\t\tid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\treturn await this.getFirst<TDocument>(\n\t\t\tappendPredicates(params, predicate.at(\"document.id\", id)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific IDs.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with IDs matching the\n\t *   `ids` parameter.\n\t */\n\tasync getByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, predicate.in(\"document.id\", ids)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific IDs.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with IDs matching the `ids` parameter.\n\t */\n\tasync getAllByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, predicate.in(\"document.id\", ids)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific UID and Custom Type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUID(\"blog_post\", \"my-first-post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t * @param documentType - The API ID of the document's Custom Type.\n\t * @param uid - UID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with a UID matching the `uid` parameter, if a\n\t *   matching document exists.\n\t */\n\tasync getByUID<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendPredicates(params, [\n\t\t\t\ttypePredicate(documentType),\n\t\t\t\tpredicate.at(`my.${documentType}.uid`, uid),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries document from the Prismic repository with specific UIDs and Custom Type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUIDs(\"blog_post\", [\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t * @param documentType - The API ID of the document's Custom Type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with UIDs matching the\n\t *   `uids` parameter.\n\t */\n\tasync getByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendPredicates(params, [\n\t\t\t\ttypePredicate(documentType),\n\t\t\t\tpredicate.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific UIDs and Custom Type.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByUIDs([\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param documentType - The API ID of the document's Custom Type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with UIDs matching the `uids` parameter.\n\t */\n\tasync getAllByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(\n\t\t\tappendPredicates(params, [\n\t\t\t\ttypePredicate(documentType),\n\t\t\t\tpredicate.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries a singleton document from the Prismic repository for a specific Custom Type.\n\t *\n\t * @remarks\n\t * A singleton document is one that is configured in Prismic to only allow one\n\t * instance. For example, a repository may be configured to contain just one\n\t * Settings document. This is in contrast to a repeatable Custom Type which\n\t * allows multiple instances of itself.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getSingle(\"settings\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t * @param documentType - The API ID of the singleton Custom Type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The singleton document for the Custom Type, if a matching document exists.\n\t */\n\tasync getSingle<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendPredicates(params, typePredicate(documentType)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository for a specific Custom Type.\n\t *\n\t * Use `getAllByType` instead if you need to query all documents for a\n\t * specific Custom Type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param documentType - The API ID of the Custom Type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents of the Custom Type.\n\t */\n\tasync getByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendPredicates(params, typePredicate(documentType)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository for a specific Custom Type.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param documentType - The API ID of the Custom Type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents of the Custom Type.\n\t */\n\tasync getAllByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(appendPredicates(params, typePredicate(documentType)));\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with a specific tag.\n\t *\n\t * Use `getAllByTag` instead if you need to query all documents with a specific tag.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByTag(\"food\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tag.\n\t */\n\tasync getByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, someTagsPredicate(tag)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with a specific tag.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByTag(\"food\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tag.\n\t */\n\tasync getAllByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, someTagsPredicate(tag)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tags.\n\t */\n\tasync getByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, everyTagPredicate(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tags.\n\t */\n\tasync getAllByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, everyTagPredicate(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with at least one of the tags.\n\t */\n\tasync getBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, someTagsPredicate(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be included.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with at least one of the tags.\n\t */\n\tasync getAllBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, someTagsPredicate(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Returns metadata about the Prismic repository, such as its refs, releases,\n\t * and custom types.\n\t *\n\t * @returns Repository metadata.\n\t */\n\tasync getRepository(params?: FetchParams): Promise<prismicT.Repository> {\n\t\t// TODO: Restore when Authorization header support works in browsers with CORS.\n\t\t// return await this.fetch<prismicT.Repository>(this.endpoint);\n\n\t\tconst url = new URL(this.endpoint);\n\n\t\tif (this.accessToken) {\n\t\t\turl.searchParams.set(\"access_token\", this.accessToken);\n\t\t}\n\n\t\treturn await this.fetch<prismicT.Repository>(url.toString(), params);\n\t}\n\n\t/**\n\t * Returns a list of all refs for the Prismic repository.\n\t *\n\t * Refs are used to identify which version of the repository's content should\n\t * be queried. All repositories will have at least one ref pointing to the\n\t * latest published content called the \"master ref\".\n\t *\n\t * @returns A list of all refs for the Prismic repository.\n\t */\n\tasync getRefs(params?: FetchParams): Promise<prismicT.Ref[]> {\n\t\tconst repository = await this.getRepository(params);\n\n\t\treturn repository.refs;\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the ref.\n\t *\n\t * @returns The ref with a matching ID, if it exists.\n\t */\n\tasync getRefByID(id: string, params?: FetchParams): Promise<prismicT.Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findRefByID(refs, id);\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getRefByLabel(\n\t\tlabel: string,\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findRefByLabel(refs, label);\n\t}\n\n\t/**\n\t * Returns the master ref for the Prismic repository. The master ref points to\n\t * the repository's latest published content.\n\t *\n\t * @returns The repository's master ref.\n\t */\n\tasync getMasterRef(params?: FetchParams): Promise<prismicT.Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findMasterRef(refs);\n\t}\n\n\t/**\n\t * Returns a list of all Releases for the Prismic repository. Releases are\n\t * used to group content changes before publishing.\n\t *\n\t * @returns A list of all Releases for the Prismic repository.\n\t */\n\tasync getReleases(params?: FetchParams): Promise<prismicT.Ref[]> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn refs.filter((ref) => !ref.isMasterRef);\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the Release.\n\t *\n\t * @returns The Release with a matching ID, if it exists.\n\t */\n\tasync getReleaseByID(\n\t\tid: string,\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Ref> {\n\t\tconst releases = await this.getReleases(params);\n\n\t\treturn findRefByID(releases, id);\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getReleaseByLabel(\n\t\tlabel: string,\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Ref> {\n\t\tconst releases = await this.getReleases(params);\n\n\t\treturn findRefByLabel(releases, label);\n\t}\n\n\t/**\n\t * Returns a list of all tags used in the Prismic repository.\n\t *\n\t * @returns A list of all tags used in the repository.\n\t */\n\tasync getTags(params?: FetchParams): Promise<string[]> {\n\t\ttry {\n\t\t\tconst tagsForm = await this.getCachedRepositoryForm(\"tags\", params);\n\n\t\t\tconst url = new URL(tagsForm.action);\n\n\t\t\tif (this.accessToken) {\n\t\t\t\turl.searchParams.set(\"access_token\", this.accessToken);\n\t\t\t}\n\n\t\t\treturn await this.fetch<string[]>(url.toString(), params);\n\t\t} catch {\n\t\t\tconst repository = await this.getRepository(params);\n\n\t\t\treturn repository.tags;\n\t\t}\n\t}\n\n\t/**\n\t * Builds a URL used to query content from the Prismic repository.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A URL string that can be requested to query content.\n\t */\n\tasync buildQueryURL({\n\t\tsignal,\n\t\t...params\n\t}: Partial<BuildQueryURLArgs> & FetchParams = {}): Promise<string> {\n\t\tconst ref = params.ref || (await this.getResolvedRefString());\n\t\tconst integrationFieldsRef =\n\t\t\tparams.integrationFieldsRef ||\n\t\t\t(await this.getCachedRepository({ signal })).integrationFieldsRef ||\n\t\t\tundefined;\n\n\t\treturn buildQueryURL(this.endpoint, {\n\t\t\t...this.defaultParams,\n\t\t\t...params,\n\t\t\tref,\n\t\t\tintegrationFieldsRef,\n\t\t\troutes: params.routes || this.routes,\n\t\t\taccessToken: params.accessToken || this.accessToken,\n\t\t});\n\t}\n\n\t/**\n\t * Determines the URL for a previewed document during an active preview\n\t * session. The result of this method should be used to redirect the user to\n\t * the document's URL.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * \tconst url = client.resolvePreviewURL({\n\t * \tlinkResolver: (document) => `/${document.uid}`\n\t * \tdefaultURL: '/'\n\t * \t})\n\t * ```\n\t *\n\t * @param args - Arguments to configure the URL resolving.\n\t *\n\t * @returns The URL for the previewed document during an active preview\n\t *   session. The user should be redirected to this URL.\n\t */\n\tasync resolvePreviewURL<LinkResolverReturnType>(\n\t\targs: ResolvePreviewArgs<LinkResolverReturnType> & FetchParams,\n\t): Promise<string> {\n\t\tlet documentID: string | undefined | null = args.documentID;\n\t\tlet previewToken: string | undefined | null = args.previewToken;\n\n\t\tif (typeof globalThis.location !== \"undefined\") {\n\t\t\tconst searchParams = new URLSearchParams(globalThis.location.search);\n\n\t\t\tdocumentID = documentID || searchParams.get(\"documentId\");\n\t\t\tpreviewToken = previewToken || searchParams.get(\"token\");\n\t\t} else if (this.refState.httpRequest) {\n\t\t\tif (\"query\" in this.refState.httpRequest) {\n\t\t\t\tdocumentID =\n\t\t\t\t\tdocumentID || (this.refState.httpRequest.query?.documentId as string);\n\t\t\t\tpreviewToken =\n\t\t\t\t\tpreviewToken || (this.refState.httpRequest.query?.token as string);\n\t\t\t} else if (\n\t\t\t\t\"url\" in this.refState.httpRequest &&\n\t\t\t\tthis.refState.httpRequest.url\n\t\t\t) {\n\t\t\t\tconst searchParams = new URL(this.refState.httpRequest.url)\n\t\t\t\t\t.searchParams;\n\n\t\t\t\tdocumentID = documentID || searchParams.get(\"documentId\");\n\t\t\t\tpreviewToken = previewToken || searchParams.get(\"token\");\n\t\t\t}\n\t\t}\n\n\t\tif (documentID != null && previewToken != null) {\n\t\t\tconst document = await this.getByID(documentID, {\n\t\t\t\tsignal: args.signal,\n\t\t\t\tref: previewToken,\n\t\t\t\tlang: \"*\",\n\t\t\t});\n\n\t\t\tconst url = prismicH.asLink(document, args.linkResolver);\n\n\t\t\tif (typeof url === \"string\") {\n\t\t\t\treturn url;\n\t\t\t}\n\t\t}\n\n\t\treturn args.defaultURL;\n\t}\n\n\t/**\n\t * Configures the client to query the latest published content for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryLatestContent();\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t */\n\tqueryLatestContent(): void {\n\t\tthis.refState.mode = RefStateMode.Master;\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its ID for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByID(\"YLB7OBAAACMA7Cpa\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param releaseID - The ID of the Release.\n\t */\n\tqueryContentFromReleaseByID(releaseID: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseID,\n\t\t\treleaseID,\n\t\t};\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its label for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByLabel(\"My Release\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param releaseLabel - The label of the Release.\n\t */\n\tqueryContentFromReleaseByLabel(releaseLabel: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseLabel,\n\t\t\treleaseLabel,\n\t\t};\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific ref. The ref can be\n\t * provided as a string or a function.\n\t *\n\t * If a function is provided, the ref is fetched lazily before each query. The\n\t * function may also be asynchronous.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromRef(\"my-ref\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param ref - The ref or a function that returns the ref from which to query content.\n\t */\n\tqueryContentFromRef(ref: RefStringOrThunk): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.Manual,\n\t\t\tref,\n\t\t};\n\t}\n\n\t/**\n\t * @deprecated Renamed to `graphQLFetch()` (note the capitalization of \"QL\").\n\t */\n\t// TODO: Remove in v3\n\tgraphqlFetch = this.graphQLFetch.bind(this);\n\n\t/**\n\t * A `fetch()` function to be used with GraphQL clients configured for\n\t * Prismic's GraphQL API. It automatically applies the necessary `prismic-ref`\n\t * and Authorization headers. Queries will automatically be minified by\n\t * removing whitespace where possible.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const graphqlClient = new ApolloClient({\n\t * \tlink: new HttpLink({\n\t * \t\turi: prismic.getGraphQLEndpoint(repositoryName),\n\t * \t\t// Provide `client.graphqlFetch` as the fetch implementation.\n\t * \t\tfetch: client.graphqlFetch,\n\t * \t\t// Using GET is required.\n\t * \t\tuseGETForQueries: true,\n\t * \t}),\n\t * \tcache: new InMemoryCache(),\n\t * });\n\t * ```\n\t *\n\t * @param input - The `fetch()` `input` parameter. Only strings are supported.\n\t * @param init - The `fetch()` `init` parameter. Only plain objects are supported.\n\t *\n\t * @returns The `fetch()` Response for the request.\n\t * @experimental\n\t */\n\tasync graphQLFetch(\n\t\tinput: RequestInfo,\n\t\tinit?: RequestInit,\n\t): Promise<Response> {\n\t\tconst cachedRepository = await this.getCachedRepository();\n\t\tconst ref = await this.getResolvedRefString();\n\n\t\tconst unsanitizedHeaders: Record<string, string> = {\n\t\t\t\"Prismic-ref\": ref,\n\t\t\t\"Prismic-integration-field-ref\":\n\t\t\t\tcachedRepository.integrationFieldsRef || \"\",\n\t\t\tAuthorization: this.accessToken ? `Token ${this.accessToken}` : \"\",\n\t\t\t// Asserting `init.headers` is a Record since popular GraphQL\n\t\t\t// libraries pass this as a Record. Header objects as input\n\t\t\t// are unsupported.\n\t\t\t...(init ? (init.headers as Record<string, string>) : {}),\n\t\t};\n\n\t\t// Normalize header keys to lowercase. This prevents header\n\t\t// conflicts between the Prismic client and the GraphQL\n\t\t// client.\n\t\tconst headers: Record<string, string> = {};\n\t\tfor (const key in unsanitizedHeaders) {\n\t\t\tif (unsanitizedHeaders[key]) {\n\t\t\t\theaders[key.toLowerCase()] =\n\t\t\t\t\tunsanitizedHeaders[key as keyof typeof unsanitizedHeaders];\n\t\t\t}\n\t\t}\n\n\t\tconst url = new URL(\n\t\t\t// Asserting `input` is a string since popular GraphQL\n\t\t\t// libraries pass this as a string. Request objects as\n\t\t\t// input are unsupported.\n\t\t\tinput as string,\n\t\t);\n\n\t\t// This prevents the request from being cached unnecessarily.\n\t\t// Without adding this `ref` param, re-running a query\n\t\t// could return a locally cached response, even if the\n\t\t// `ref` changed. This happens because the URL is\n\t\t// identical when the `ref` is not included. Caches may ignore\n\t\t// headers.\n\t\t//\n\t\t// The Prismic GraphQL API ignores the `ref` param.\n\t\turl.searchParams.set(\"ref\", ref);\n\n\t\tconst query = url.searchParams.get(\"query\");\n\t\tif (query) {\n\t\t\turl.searchParams.set(\n\t\t\t\t\"query\",\n\t\t\t\t// Compress the GraphQL query (if it exists) by\n\t\t\t\t// removing whitespace. This is done to\n\t\t\t\t// optimize the query size and avoid\n\t\t\t\t// hitting the upper limit of GET requests\n\t\t\t\t// (2048 characters).\n\t\t\t\tminifyGraphQLQuery(query),\n\t\t\t);\n\t\t}\n\n\t\treturn (await this.fetchFn(url.toString(), {\n\t\t\t...init,\n\t\t\theaders,\n\t\t})) as Response;\n\t}\n\n\t/**\n\t * Returns a cached version of `getRepository` with a TTL.\n\t *\n\t * @returns Cached repository metadata.\n\t */\n\tprivate async getCachedRepository(\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Repository> {\n\t\tif (\n\t\t\t!this.cachedRepository ||\n\t\t\tDate.now() >= this.cachedRepositoryExpiration\n\t\t) {\n\t\t\tthis.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL;\n\t\t\tthis.cachedRepository = await this.getRepository(params);\n\t\t}\n\n\t\treturn this.cachedRepository;\n\t}\n\n\t/**\n\t * Returns a cached Prismic repository form. Forms are used to determine API\n\t * endpoints for types of repository data.\n\t *\n\t * @param name - Name of the form.\n\t *\n\t * @returns The repository form.\n\t * @throws If a matching form cannot be found.\n\t */\n\tprivate async getCachedRepositoryForm(\n\t\tname: string,\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Form> {\n\t\tconst cachedRepository = await this.getCachedRepository(params);\n\t\tconst form = cachedRepository.forms[name];\n\n\t\tif (!form) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`Form with name \"${name}\" could not be found`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t);\n\t\t}\n\n\t\treturn form;\n\t}\n\n\t/**\n\t * Returns the ref needed to query based on the client's current state. This\n\t * method may make a network request to fetch a ref or resolve the user's ref thunk.\n\t *\n\t * If auto previews are enabled, the preview ref takes priority if available.\n\t *\n\t * The following strategies are used depending on the client's state:\n\t *\n\t * - If the user called `queryLatestContent`: Use the repository's master ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is fetched.\n\t * - If the user called `queryContentFromReleaseByID`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromRef`: Use the provided ref. Fall back\n\t *   to the master ref if the ref is not a string.\n\t *\n\t * @returns The ref to use during a query.\n\t */\n\tprivate async getResolvedRefString(params?: FetchParams): Promise<string> {\n\t\tif (this.refState.autoPreviewsEnabled) {\n\t\t\tlet previewRef: string | undefined;\n\n\t\t\tlet cookieJar: string | null | undefined;\n\n\t\t\tif (globalThis.document?.cookie) {\n\t\t\t\tcookieJar = globalThis.document.cookie;\n\t\t\t} else if (this.refState.httpRequest?.headers) {\n\t\t\t\tif (\n\t\t\t\t\t\"get\" in this.refState.httpRequest.headers &&\n\t\t\t\t\ttypeof this.refState.httpRequest.headers.get === \"function\"\n\t\t\t\t) {\n\t\t\t\t\t// Web API Headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.get(\"cookie\");\n\t\t\t\t} else if (\"cookie\" in this.refState.httpRequest.headers) {\n\t\t\t\t\t// Express-style headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.cookie;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cookieJar) {\n\t\t\t\tpreviewRef = getCookie(cookie.preview, cookieJar);\n\t\t\t}\n\n\t\t\tif (previewRef) {\n\t\t\t\treturn previewRef;\n\t\t\t}\n\t\t}\n\n\t\tconst cachedRepository = await this.getCachedRepository(params);\n\n\t\tconst refModeType = this.refState.mode;\n\t\tif (refModeType === RefStateMode.ReleaseID) {\n\t\t\treturn findRefByID(cachedRepository.refs, this.refState.releaseID).ref;\n\t\t} else if (refModeType === RefStateMode.ReleaseLabel) {\n\t\t\treturn findRefByLabel(cachedRepository.refs, this.refState.releaseLabel)\n\t\t\t\t.ref;\n\t\t} else if (refModeType === RefStateMode.Manual) {\n\t\t\tconst res = await castThunk(this.refState.ref)();\n\n\t\t\tif (typeof res === \"string\") {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\treturn findMasterRef(cachedRepository.refs).ref;\n\t}\n\n\t/**\n\t * Performs a network request using the configured `fetch` function. It\n\t * assumes all successful responses will have a JSON content type. It also\n\t * normalizes unsuccessful network requests.\n\t *\n\t * @typeParam T - The JSON response.\n\t * @param url - URL to the resource to fetch.\n\t * @param params - Prismic REST API parameters for the network request.\n\t *\n\t * @returns The JSON response from the network request.\n\t */\n\tprivate async fetch<T = unknown>(\n\t\turl: string,\n\t\t// TODO: Change to `params` when Authorization header support works in browsers with CORS.\n\t\t// _params?: Partial<BuildQueryURLArgs>,\n\t\tparams: FetchParams = {},\n\t): Promise<T> {\n\t\t// TODO: Restore when Authorization header support works in browsers with CORS.\n\t\t// const accessToken = (params && params.accessToken) || this.accessToken;\n\t\t// const options = accessToken\n\t\t// \t? { headers: { Authorization: `Token ${accessToken}` } }\n\t\t// \t: {};\n\n\t\tconst res = await this.fetchFn(url, {\n\t\t\tsignal: params.signal,\n\t\t});\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tlet json: any;\n\t\ttry {\n\t\t\t// We can assume Prismic REST API responses will have a `application/json`\n\t\t\t// Content Type. If not, this will throw, signaling an invalid response.\n\t\t\tjson = await res.json();\n\t\t} catch {\n\t\t\t// Not Found (this response has an empty body and throws on `.json()`)\n\t\t\t// - Incorrect repository name\n\t\t\tif (res.status === 404) {\n\t\t\t\tthrow new NotFoundError(\n\t\t\t\t\t`Prismic repository not found. Check that \"${this.endpoint}\" is pointing to the correct repository.`,\n\t\t\t\t\turl,\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthrow new PrismicError(undefined, url, undefined);\n\t\t\t}\n\t\t}\n\n\t\tswitch (res.status) {\n\t\t\t// Successful\n\t\t\tcase 200: {\n\t\t\t\treturn json;\n\t\t\t}\n\n\t\t\t// Bad Request\n\t\t\t// - Invalid predicate syntax\n\t\t\t// - Ref not provided (ignored)\n\t\t\tcase 400: {\n\t\t\t\tthrow new ParsingError(json.message, url, json);\n\t\t\t}\n\n\t\t\t// Unauthorized\n\t\t\t// - Missing access token for repository endpoint\n\t\t\t// - Incorrect access token for repository endpoint\n\t\t\tcase 401:\n\t\t\t// Forbidden\n\t\t\t// - Missing access token for query endpoint\n\t\t\t// - Incorrect access token for query endpoint\n\t\t\tcase 403: {\n\t\t\t\tthrow new ForbiddenError(\n\t\t\t\t\t\"error\" in json ? json.error : json.message,\n\t\t\t\t\turl,\n\t\t\t\t\tjson,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthrow new PrismicError(undefined, url, json);\n\t}\n}\n","// Primary library API.\nimport { getRepositoryEndpoint } from \"./getRepositoryEndpoint\";\nexport { getRepositoryEndpoint };\n/**\n * @deprecated Renamed to `getRepositoryEndpoint`.\n */\n// TODO: Remove in v3.\nexport const getEndpoint = getRepositoryEndpoint;\nexport { getRepositoryName } from \"./getRepositoryName\";\nexport { getGraphQLEndpoint } from \"./getGraphQLEndpoint\";\nexport { isRepositoryName } from \"./isRepositoryName\";\nexport { isRepositoryEndpoint } from \"./isRepositoryEndpoint\";\nexport { buildQueryURL } from \"./buildQueryURL\";\nexport { createClient, Client } from \"./client\";\n\n// Predicates API.\nimport { predicate } from \"./predicate\";\nexport { predicate };\n/**\n * @deprecated Renamed to `predicate` (without an \"s\").\n */\n// TODO: Remove in v3.\nexport const predicates = predicate;\n/**\n * @deprecated Renamed to `predicate` (lowercase and without an \"s\").\n */\n// TODO: Remove in v3.\nexport const Predicates = predicate;\n\n// Custom errors used by Client.\nexport { PrismicError } from \"./PrismicError\";\nexport { ForbiddenError } from \"./ForbiddenError\";\nexport { ParsingError } from \"./ParsingError\";\nexport { NotFoundError } from \"./NotFoundError\";\n\n// A collection of well-known cookie names shared between Prismic libraries and systems.\nexport * as cookie from \"./cookie\";\n\n// General types used throughout the project. These are made public to allow users to better type their projects.\nexport type { CreateClient, ClientConfig } from \"./client\";\nexport type { QueryParams, BuildQueryURLArgs } from \"./buildQueryURL\";\nexport type {\n\tFetchLike,\n\tHttpRequestLike,\n\tOrdering,\n\tRequestInitLike,\n\tResponseLike,\n\tRoute,\n} from \"./types\";\n"],"names":["prismicH","cookie.preview"],"mappings":"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"}