{"version":3,"file":"index.cjs","sources":["../src/asTree.ts","../src/asText.ts","../src/serialize.ts","../src/types.ts","../src/wrapMapSerializer.ts","../src/composeSerializers.ts"],"sourcesContent":["import {\n\tRichTextNodeType,\n\tRTAnyNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTListItemNode,\n\tRTNode,\n\tRTOListItemNode,\n\tRTTextNode,\n} from \"@prismicio/types\";\nimport { Tree, TreeNode } from \"./types\";\n\nconst uuid = (): string => {\n\treturn (++uuid.i).toString();\n};\nuuid.i = 0;\n\n/**\n * Parses a rich text or title field into a tree\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages. Most users aren't expected to this function directly.\n * @param nodes - A rich text or title field from Prismic\n *\n * @returns Tree from given rich text or title field\n */\nexport const asTree = (nodes: RTNode[]): Tree => {\n\tconst preparedNodes = prepareNodes(nodes);\n\n\tconst children: TreeNode[] = [];\n\tfor (let i = 0; i < preparedNodes.length; i++) {\n\t\tchildren.push(nodeToTreeNode(preparedNodes[i]));\n\t}\n\n\treturn {\n\t\tkey: uuid(),\n\t\tchildren,\n\t};\n};\n\nconst createTreeNode = (\n\tnode: RTAnyNode,\n\tchildren: TreeNode[] = [],\n): TreeNode => {\n\treturn {\n\t\tkey: uuid(),\n\t\ttype: node.type,\n\t\ttext: \"text\" in node ? node.text : undefined,\n\t\tnode,\n\t\tchildren,\n\t};\n};\n\nconst createTextTreeNode = (text: string): TreeNode => {\n\treturn createTreeNode({\n\t\ttype: RichTextNodeType.span,\n\t\ttext,\n\t\tspans: [],\n\t});\n};\n\nconst prepareNodes = (nodes: RTNode[]): RTBlockNode[] => {\n\tconst mutNodes: RTBlockNode[] = nodes.slice(0);\n\n\tfor (let i = 0; i < mutNodes.length; i++) {\n\t\tconst node = mutNodes[i];\n\n\t\tif (\n\t\t\tnode.type === RichTextNodeType.listItem ||\n\t\t\tnode.type === RichTextNodeType.oListItem\n\t\t) {\n\t\t\tconst items: (RTListItemNode | RTOListItemNode)[] = [\n\t\t\t\tnode as RTListItemNode | RTOListItemNode,\n\t\t\t];\n\n\t\t\twhile (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n\t\t\t\titems.push(mutNodes[i + 1] as RTListItemNode | RTOListItemNode);\n\t\t\t\tmutNodes.splice(i, 1);\n\t\t\t}\n\n\t\t\tif (node.type === RichTextNodeType.listItem) {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.list,\n\t\t\t\t\titems: items as RTListItemNode[],\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.oList,\n\t\t\t\t\titems: items as RTOListItemNode[],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mutNodes;\n};\n\nconst nodeToTreeNode = (node: RTBlockNode): TreeNode => {\n\tif (\"text\" in node) {\n\t\treturn createTreeNode(\n\t\t\tnode,\n\t\t\ttextNodeSpansToTreeNodeChildren(node.spans, node),\n\t\t);\n\t}\n\n\tif (\"items\" in node) {\n\t\tconst children: TreeNode[] = [];\n\t\tfor (let i = 0; i < node.items.length; i++) {\n\t\t\tchildren.push(nodeToTreeNode(node.items[i]));\n\t\t}\n\n\t\treturn createTreeNode(node, children);\n\t}\n\n\treturn createTreeNode(node);\n};\n\nconst textNodeSpansToTreeNodeChildren = (\n\tspans: RTInlineNode[],\n\tnode: RTTextNode,\n\tparentSpan?: RTInlineNode,\n): TreeNode[] => {\n\tif (!spans.length) {\n\t\treturn [createTextTreeNode(node.text)];\n\t}\n\n\tconst mutSpans: RTInlineNode[] = spans.slice(0);\n\n\t// Sort spans using the following criteria:\n\t//\n\t//   1. By start index (ascending)\n\t//   2. If start indices are equal, by end index (descending)\n\t//\n\t// If start and end indices of more than one span are equal, use what\n\t// the API gives without modifications.\n\t//\n\t// Sorting using this algorithm ensures proper detection of child\n\t// spans.\n\tmutSpans.sort((a, b) => a.start - b.start || b.end - a.end);\n\n\tconst children: TreeNode[] = [];\n\n\tfor (let i = 0; i < mutSpans.length; i++) {\n\t\tconst span = mutSpans[i];\n\t\tconst parentSpanStart = (parentSpan && parentSpan.start) || 0;\n\t\tconst spanStart = span.start - parentSpanStart;\n\t\tconst spanEnd = span.end - parentSpanStart;\n\t\tconst text = node.text.slice(spanStart, spanEnd);\n\n\t\tconst childSpans: RTInlineNode[] = [];\n\t\tfor (let j = i; j < mutSpans.length; j++) {\n\t\t\tconst siblingSpan = mutSpans[j];\n\n\t\t\tif (\n\t\t\t\tsiblingSpan !== span &&\n\t\t\t\tsiblingSpan.start >= span.start &&\n\t\t\t\tsiblingSpan.end <= span.end\n\t\t\t) {\n\t\t\t\tchildSpans.push(siblingSpan);\n\t\t\t\tmutSpans.splice(j, 1);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\n\t\tif (i === 0 && spanStart > 0) {\n\t\t\tchildren.push(createTextTreeNode(node.text.slice(0, spanStart)));\n\t\t}\n\n\t\tconst spanWithText = { ...span, text };\n\t\tchildren.push(\n\t\t\tcreateTreeNode(\n\t\t\t\tspanWithText,\n\t\t\t\ttextNodeSpansToTreeNodeChildren(\n\t\t\t\t\tchildSpans,\n\t\t\t\t\t{\n\t\t\t\t\t\t...node,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t},\n\t\t\t\t\tspan,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif (spanEnd < node.text.length) {\n\t\t\tchildren.push(\n\t\t\t\tcreateTextTreeNode(\n\t\t\t\t\tnode.text.slice(\n\t\t\t\t\t\tspanEnd,\n\t\t\t\t\t\tmutSpans[i + 1]\n\t\t\t\t\t\t\t? mutSpans[i + 1].start - parentSpanStart\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn children;\n};\n","import { RichTextField, RTTextNode } from \"@prismicio/types\";\n\n/**\n * Serializes a rich text or title field to a plain text string\n *\n * @param richTextField - A rich text or title field from Prismic\n * @param separator - Separator used to join each element, defaults to a space\n *\n * @returns Plain text equivalent of the provided rich text or title field\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const asText = (\n\trichTextField: RichTextField,\n\tseparator = \" \",\n): string => {\n\tlet result = \"\";\n\n\tfor (let i = 0; i < richTextField.length; i++) {\n\t\tif (\"text\" in richTextField[i]) {\n\t\t\tresult +=\n\t\t\t\t(result ? separator : \"\") + (richTextField[i] as RTTextNode).text;\n\t\t}\n\t}\n\n\treturn result;\n};\n","import { RichTextField } from \"@prismicio/types\";\nimport { RichTextFunctionSerializer, TreeNode } from \"./types\";\nimport { asTree } from \"./asTree\";\n\n/**\n * Serializes a rich text or title field with a given serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of the serializer\n * @param richTextField - A rich text or title field from Prismic\n * @param serializer - A function serializer to apply\n *\n * @returns An array of serialized nodes\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const serialize = <SerializerReturnType>(\n\trichTextField: RichTextField,\n\tserializer: RichTextFunctionSerializer<SerializerReturnType>,\n): SerializerReturnType[] => {\n\treturn serializeTreeNodes<SerializerReturnType>(\n\t\tasTree(richTextField).children,\n\t\tserializer,\n\t);\n};\n\nconst serializeTreeNodes = <T>(\n\tnodes: TreeNode[],\n\tserializer: RichTextFunctionSerializer<T>,\n): T[] => {\n\tconst serializedTreeNodes: T[] = [];\n\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\tconst treeNode = nodes[i];\n\t\tconst serializedTreeNode = serializer(\n\t\t\ttreeNode.type,\n\t\t\ttreeNode.node,\n\t\t\ttreeNode.text,\n\t\t\tserializeTreeNodes(treeNode.children, serializer),\n\t\t\ttreeNode.key,\n\t\t);\n\n\t\tif (serializedTreeNode != null) {\n\t\t\tserializedTreeNodes.push(serializedTreeNode);\n\t\t}\n\t}\n\n\treturn serializedTreeNodes;\n};\n","import {\n\tRichTextNodeType,\n\tRTAnyNode,\n\tRTEmbedNode,\n\tRTEmNode,\n\tRTHeading1Node,\n\tRTHeading2Node,\n\tRTHeading3Node,\n\tRTHeading4Node,\n\tRTHeading5Node,\n\tRTHeading6Node,\n\tRTImageNode,\n\tRTLabelNode,\n\tRTLinkNode,\n\tRTListItemNode,\n\tRTListNode,\n\tRTOListItemNode,\n\tRTOListNode,\n\tRTParagraphNode,\n\tRTPreformattedNode,\n\tRTSpanNode,\n\tRTStrongNode,\n} from \"@prismicio/types\";\n\n// Serializers\n\n/**\n * Serializes a node from a rich text or title field with a function\n *\n * @typeParam ReturnType - Return type of the function serializer\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextFunctionSerializer<ReturnType> = (\n\ttype: typeof RichTextNodeType[keyof typeof RichTextNodeType],\n\tnode: RTAnyNode,\n\ttext: string | undefined,\n\tchildren: ReturnType[],\n\tkey: string,\n) => ReturnType | null | undefined;\n\n/**\n * Map serializer's tag function serializer, can be helpful for typing those handlers\n *\n * @typeParam ReturnType - Return type of the tag serializer\n */\nexport type RichTextMapSerializerFunction<\n\tReturnType,\n\tNode extends RTAnyNode = RTAnyNode,\n\tTextType = string | undefined,\n> = (payload: {\n\ttype: Node[\"type\"];\n\tnode: Node;\n\ttext: TextType;\n\tchildren: ReturnType[];\n\tkey: string;\n}) => ReturnType | null | undefined;\n\n/**\n * Serializes a node from a rich text or title field with a map\n *\n * @remarks\n * This type of serializer needs to be processed through\n * {@link wrapMapSerializer} before being used with {@link serialize}\n * @typeParam ReturnType - Return type of the map serializer\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextMapSerializer<ReturnType> = {\n\theading1?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading1Node,\n\t\tundefined\n\t>;\n\theading2?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading2Node,\n\t\tundefined\n\t>;\n\theading3?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading3Node,\n\t\tundefined\n\t>;\n\theading4?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading4Node,\n\t\tundefined\n\t>;\n\theading5?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading5Node,\n\t\tundefined\n\t>;\n\theading6?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading6Node,\n\t\tundefined\n\t>;\n\tparagraph?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTParagraphNode,\n\t\tundefined\n\t>;\n\tpreformatted?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTPreformattedNode,\n\t\tundefined\n\t>;\n\tstrong?: RichTextMapSerializerFunction<ReturnType, RTStrongNode, string>;\n\tem?: RichTextMapSerializerFunction<ReturnType, RTEmNode, string>;\n\tlistItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTListItemNode,\n\t\tundefined\n\t>;\n\toListItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTOListItemNode,\n\t\tundefined\n\t>;\n\tlist?: RichTextMapSerializerFunction<ReturnType, RTListNode, undefined>;\n\toList?: RichTextMapSerializerFunction<ReturnType, RTOListNode, undefined>;\n\timage?: RichTextMapSerializerFunction<ReturnType, RTImageNode, undefined>;\n\tembed?: RichTextMapSerializerFunction<ReturnType, RTEmbedNode, undefined>;\n\thyperlink?: RichTextMapSerializerFunction<ReturnType, RTLinkNode, string>;\n\tlabel?: RichTextMapSerializerFunction<ReturnType, RTLabelNode, string>;\n\tspan?: RichTextMapSerializerFunction<ReturnType, RTSpanNode, string>;\n};\n\n// Tree\nexport interface Tree {\n\tkey: string;\n\tchildren: TreeNode[];\n}\n\nexport interface TreeNode {\n\tkey: string;\n\ttype: typeof RichTextNodeType[keyof typeof RichTextNodeType];\n\ttext?: string;\n\tnode: RTAnyNode;\n\tchildren: TreeNode[];\n}\n\n// Helpers\nexport const RichTextReversedNodeType = {\n\t[RichTextNodeType.listItem]: \"listItem\",\n\t[RichTextNodeType.oListItem]: \"oListItem\",\n\t[RichTextNodeType.list]: \"list\",\n\t[RichTextNodeType.oList]: \"oList\",\n} as const;\n","import {\n\tRichTextFunctionSerializer,\n\tRichTextMapSerializer,\n\tRichTextReversedNodeType,\n} from \"./types\";\n\n/**\n * Wraps a map serializer into a regular function serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of the map serializer\n * @param mapSerializer - Map serializer to wrap\n *\n * @returns A regular function serializer\n */\nexport const wrapMapSerializer = <SerializerReturnType>(\n\tmapSerializer: RichTextMapSerializer<SerializerReturnType>,\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (type, node, text, children, key) => {\n\t\tconst tagSerializer: RichTextMapSerializer<SerializerReturnType>[keyof RichTextMapSerializer<SerializerReturnType>] =\n\t\t\tmapSerializer[\n\t\t\t\t(RichTextReversedNodeType[\n\t\t\t\t\ttype as keyof typeof RichTextReversedNodeType\n\t\t\t\t] || type) as keyof RichTextMapSerializer<SerializerReturnType>\n\t\t\t];\n\n\t\tif (tagSerializer) {\n\t\t\treturn tagSerializer({\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttype,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tnode,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttext,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tchildren,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tkey,\n\t\t\t});\n\t\t}\n\t};\n};\n","import { RichTextFunctionSerializer } from \"./types\";\n\n/**\n * Takes an array of serializers and returns a serializer applying provided\n * serializers sequentially until a result is returned\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of serializers\n * @param serializers - Serializers to compose\n *\n * @returns Composed serializer\n */\nexport const composeSerializers = <SerializerReturnType>(\n\t...serializers: (\n\t\t| RichTextFunctionSerializer<SerializerReturnType>\n\t\t| undefined\n\t)[]\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (...args) => {\n\t\tfor (let i = 0; i < serializers.length; i++) {\n\t\t\tconst serializer = serializers[i];\n\n\t\t\tif (serializer) {\n\t\t\t\tconst res = serializer(...args);\n\n\t\t\t\tif (res != null) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n"],"names":["RichTextNodeType"],"mappings":"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"}