import { LinkType, RichTextNodeType } from '@prismicio/types';
import { asText as asText$1, composeSerializers, wrapMapSerializer, Element, serialize } from '@prismicio/richtext';
export { Element } from '@prismicio/richtext';
import escapeHtml from 'escape-html';
import { buildURL, buildWidthSrcSet, buildPixelDensitySrcSet } from 'imgix-url-builder';

const asDate = (dateOrTimestampField) => {
  if (!dateOrTimestampField) {
    return null;
  }
  if (dateOrTimestampField.length === 24) {
    return new Date(dateOrTimestampField.replace(/(\+|-)(\d{2})(\d{2})$/, ".000$1$2:$3"));
  } else {
    return new Date(dateOrTimestampField);
  }
};

const documentToLinkField = (prismicDocument) => {
  var _a, _b, _c;
  return {
    link_type: LinkType.Document,
    id: prismicDocument.id,
    uid: (_a = prismicDocument.uid) != null ? _a : void 0,
    type: prismicDocument.type,
    tags: prismicDocument.tags,
    lang: prismicDocument.lang,
    url: (_b = prismicDocument.url) != null ? _b : void 0,
    slug: (_c = prismicDocument.slugs) == null ? void 0 : _c[0],
    ...prismicDocument.data && Object.keys(prismicDocument.data).length > 0 ? { data: prismicDocument.data } : {}
  };
};

const asLink = (linkFieldOrDocument, linkResolver) => {
  if (!linkFieldOrDocument) {
    return null;
  }
  const linkField = "link_type" in linkFieldOrDocument ? linkFieldOrDocument : documentToLinkField(linkFieldOrDocument);
  switch (linkField.link_type) {
    case LinkType.Media:
    case LinkType.Web:
      return "url" in linkField ? linkField.url : null;
    case LinkType.Document: {
      if ("id" in linkField && linkResolver) {
        const resolvedURL = linkResolver(linkField);
        if (resolvedURL != null) {
          return resolvedURL;
        }
      }
      if ("url" in linkField && linkField.url) {
        return linkField.url;
      }
      return null;
    }
    case LinkType.Any:
    default:
      return null;
  }
};

const asText = (richTextField, separator) => {
  if (richTextField) {
    return asText$1(richTextField, separator);
  } else {
    return null;
  }
};

const getLabel = (node) => {
  return "data" in node && "label" in node.data ? ` class="${node.data.label}"` : "";
};
const serializeStandardTag = (tag, node, children) => {
  return `<${tag}${getLabel(node)}>${children.join("")}</${tag}>`;
};
const serializePreFormatted = (node) => {
  return `<pre${getLabel(node)}>${escapeHtml(node.text)}</pre>`;
};
const serializeImage = (linkResolver, node) => {
  let imageTag = `<img src="${node.url}" alt="${escapeHtml(node.alt)}"${node.copyright ? ` copyright="${escapeHtml(node.copyright)}"` : ""} />`;
  if (node.linkTo) {
    imageTag = serializeHyperlink(linkResolver, {
      type: RichTextNodeType.hyperlink,
      data: node.linkTo,
      start: 0,
      end: 0
    }, [imageTag]);
  }
  return `<p class="block-img">${imageTag}</p>`;
};
const serializeEmbed = (node) => {
  return `<div data-oembed="${node.oembed.embed_url}" data-oembed-type="${node.oembed.type}" data-oembed-provider="${node.oembed.provider_name}"${getLabel(node)}>${node.oembed.html}</div>`;
};
const serializeHyperlink = (linkResolver, node, children) => {
  switch (node.data.link_type) {
    case LinkType.Web: {
      return `<a href="${escapeHtml(node.data.url)}" target="${node.data.target}" rel="noopener noreferrer"${getLabel(node)}>${children.join("")}</a>`;
    }
    case LinkType.Document: {
      return `<a href="${asLink(node.data, linkResolver)}"${getLabel(node)}>${children.join("")}</a>`;
    }
    case LinkType.Media: {
      return `<a href="${node.data.url}"${getLabel(node)}>${children.join("")}</a>`;
    }
  }
};
const serializeSpan = (content) => {
  return content ? escapeHtml(content).replace(/\n/g, "<br />") : "";
};

const createDefaultHTMLSerializer = (linkResolver) => {
  return (_type, node, text, children, _key) => {
    switch (node.type) {
      case Element.heading1:
        return serializeStandardTag("h1", node, children);
      case Element.heading2:
        return serializeStandardTag("h2", node, children);
      case Element.heading3:
        return serializeStandardTag("h3", node, children);
      case Element.heading4:
        return serializeStandardTag("h4", node, children);
      case Element.heading5:
        return serializeStandardTag("h5", node, children);
      case Element.heading6:
        return serializeStandardTag("h6", node, children);
      case Element.paragraph:
        return serializeStandardTag("p", node, children);
      case Element.preformatted:
        return serializePreFormatted(node);
      case Element.strong:
        return serializeStandardTag("strong", node, children);
      case Element.em:
        return serializeStandardTag("em", node, children);
      case Element.listItem:
        return serializeStandardTag("li", node, children);
      case Element.oListItem:
        return serializeStandardTag("li", node, children);
      case Element.list:
        return serializeStandardTag("ul", node, children);
      case Element.oList:
        return serializeStandardTag("ol", node, children);
      case Element.image:
        return serializeImage(linkResolver, node);
      case Element.embed:
        return serializeEmbed(node);
      case Element.hyperlink:
        return serializeHyperlink(linkResolver, node, children);
      case Element.label:
        return serializeStandardTag("span", node, children);
      case Element.span:
      default:
        return serializeSpan(text);
    }
  };
};
const wrapMapSerializerWithStringChildren = (mapSerializer) => {
  const modifiedMapSerializer = {};
  for (const tag in mapSerializer) {
    const tagSerializer = mapSerializer[tag];
    if (tagSerializer) {
      modifiedMapSerializer[tag] = (payload) => {
        return tagSerializer({
          ...payload,
          children: payload.children.join("")
        });
      };
    }
  }
  return wrapMapSerializer(modifiedMapSerializer);
};
const asHTML = (richTextField, linkResolver, htmlSerializer) => {
  if (richTextField) {
    let serializer;
    if (htmlSerializer) {
      serializer = composeSerializers(typeof htmlSerializer === "object" ? wrapMapSerializerWithStringChildren(htmlSerializer) : (type, node, text, children, key) => htmlSerializer(type, node, text, children.join(""), key), createDefaultHTMLSerializer(linkResolver));
    } else {
      serializer = createDefaultHTMLSerializer(linkResolver);
    }
    return serialize(richTextField, serializer).join("");
  } else {
    return null;
  }
};

const isNonNullish = (input) => {
  return input != null;
};
const isNonEmptyArray = (input) => {
  return !!input.length;
};
const richText = (field) => {
  if (!isNonNullish(field)) {
    return false;
  } else if (field.length === 1 && "text" in field[0]) {
    return !!field[0].text;
  } else {
    return !!field.length;
  }
};
const title = richText;
const imageThumbnail = (thumbnail) => {
  return isNonNullish(thumbnail) && !!thumbnail.url;
};
const image = imageThumbnail;
const link = (field) => {
  return isNonNullish(field) && ("id" in field || "url" in field);
};
const linkToMedia = link;
const contentRelationship = link;
const date = isNonNullish;
const timestamp = isNonNullish;
const color = isNonNullish;
const number = isNonNullish;
const keyText = (field) => {
  return isNonNullish(keyText) && !!field;
};
const select = isNonNullish;
const embed = (field) => {
  return isNonNullish(field) && !!field.embed_url;
};
const geoPoint = (field) => {
  return isNonNullish(field) && "longitude" in field;
};
const integrationFields = isNonNullish;
const group = (group2) => {
  return isNonNullish(group2) && isNonEmptyArray(group2);
};
const sliceZone = (slices) => {
  return isNonNullish(slices) && isNonEmptyArray(slices);
};

var isFilled = /*#__PURE__*/Object.freeze({
	__proto__: null,
	richText: richText,
	title: title,
	imageThumbnail: imageThumbnail,
	image: image,
	link: link,
	linkToMedia: linkToMedia,
	contentRelationship: contentRelationship,
	date: date,
	timestamp: timestamp,
	color: color,
	number: number,
	keyText: keyText,
	select: select,
	embed: embed,
	geoPoint: geoPoint,
	integrationFields: integrationFields,
	group: group,
	sliceZone: sliceZone
});

const asImageSrc = (field, params = {}) => {
  if (field && imageThumbnail(field)) {
    return buildURL(field.url, params);
  } else {
    return null;
  }
};

const DEFAULT_WIDTHS = [640, 828, 1200, 2048, 3840];
const asImageWidthSrcSet = (field, params = {}) => {
  if (field && imageThumbnail(field)) {
    let {
      widths = DEFAULT_WIDTHS,
      ...imgixParams
    } = params;
    const {
      url,
      dimensions,
      alt: _alt,
      copyright: _copyright,
      ...responsiveViews
    } = field;
    const responsiveViewObjects = Object.values(responsiveViews);
    if (widths === "thumbnails" && responsiveViewObjects.length < 1) {
      widths = DEFAULT_WIDTHS;
    }
    return {
      src: buildURL(url, imgixParams),
      srcset: widths === "thumbnails" ? [
        buildWidthSrcSet(url, {
          ...imgixParams,
          widths: [dimensions.width]
        }),
        ...responsiveViewObjects.map((thumbnail) => {
          return buildWidthSrcSet(thumbnail.url, {
            ...imgixParams,
            widths: [thumbnail.dimensions.width]
          });
        })
      ].join(", ") : buildWidthSrcSet(field.url, {
        ...imgixParams,
        widths
      })
    };
  } else {
    return null;
  }
};

const DEFAULT_PIXEL_DENSITIES = [1, 2, 3];
const asImagePixelDensitySrcSet = (field, params = {}) => {
  if (field && imageThumbnail(field)) {
    const { pixelDensities = DEFAULT_PIXEL_DENSITIES, ...imgixParams } = params;
    return {
      src: buildURL(field.url, imgixParams),
      srcset: buildPixelDensitySrcSet(field.url, {
        ...imgixParams,
        pixelDensities
      })
    };
  } else {
    return null;
  }
};

const Elements = Element;

export { Elements, asDate, asHTML, asImagePixelDensitySrcSet, asImageSrc, asImageWidthSrcSet, asLink, asText, documentToLinkField, isFilled };
//# sourceMappingURL=index.js.map
